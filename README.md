sosuupoyo-shogi-packer
====

将棋の局面を256bitのビット列に高速にエンコード可能なSSPFv1の参照実装です。
高速なpack/unpackのためには、PEXT/PDEP命令をサポートするCPUが必要です(BMI2対応CPU)。
PEXTが高速でないCPUのうち、AVX2が利用可能な場合はある程度の高速化が期待できます。
AVX2も利用できない場合は、PackedSfenの方が高速です。

## ベンチマーク

AMD Ryzen 9 7950X3D 上でのベンチマーク結果です。

PackedSfenは --features byteboard オプション付きでビルドしています。
このオプションを付けると、盤面の状態を表すboard変数を追加で持つようになり、packが高速化されます。

一方、SSPFv1はboard変数は不要で、逆にunpack時に盤面を復元するコストが増えるため、--features byteboard オプションは付けていません。

### pack

| flags | PackedSfen (ns/iter) | SSPFv1 (ns/iter) | Speedup |
|-------|----------------------|------------------|---------|
| none  | 94.13                | 167.90           | 0.56x   |
| target-cpu=native | 106.36   | 10.23            | 10.3x   |
| target-feature=+bmi2 | 94.16 | 14.53            | 6.48x   |
| target-feature=+avx2 | 94.60 | 40.27            | 2.35x   |
| target-feature=+sse4.2 | 94.43 | 124.62         | 0.76x   |

### unpack

| flags | PackedSfen (ns/iter) | SSPFv1 (ns/iter) | Speedup |
|-------|----------------------|------------------|---------|
| none  | 228.61               | 125.54           | 1.82x   |
| target-cpu=native | 218.89   | 19.10            | 11.5x   |
| target-feature=+bmi2 | 235.37 | 32.10           | 7.33x   |
| target-feature=+avx2 | 224.46 | 123.43          | 1.82x   |
| target-feature=+sse4.2 | 230.82 | 124.67        | 1.85x   |

## ファイル構成

- `src/packer.rs`: Packerトレイトの定義。
- `src/packed_sfen.rs`: PackedSfenフォーマットのエンコード実装。
- `src/sspfv1.rs`: SSPFv1フォーマットのエンコード実装。
- `src/position.rs`: 将棋の局面表現。Bitboard、駒、持ち駒、局面を表す最小限の実装（shogi\_coreクレートベース）。
- `src/pext.rs`: PEXT命令のラッパー。BMI2対応CPUでは`_pext_u64`を使用。
- `src/pdep.rs`: PDEP命令のラッパー。PEXT同様にBMI2対応CPUでは`_pdep_u64`を使用。

## SSPFv1 (Sosuupoyo's Shogi Position Format version 1)

### 各フィールドの説明

SSPFv1は256ビットで構成され、以下の10フィールドのビットを順に連結してエンコードします。

| フィールド名 | サイズ (bits) | 説明 | 駒種 | オフセット (bits) |
|--------------|---------------|------|------|-------------------|
| side\_to\_move | 1 | 0: 先手, 1: 後手 | - | 0 |
| occupied | 79 | 玉のあるマス以外の駒の有無 | 歩香桂銀金角飛 | 1 |
| kings | 14 | 先後それぞれの玉の位置 (7 bits × 2) | 玉 | 80 |
| is\_promoted | 34 | 成りフラグ | 歩香桂銀角飛 | 94 |
| pt\_bit 0 | 38 | 駒種を決定するハフマン符号の0ビット目 | 歩香桂銀金角飛 | 128 |
| pt\_bit 1 | 20 | 駒種を決定するハフマン符号の1ビット目 | 香桂銀金角飛 | 166 |
| pt\_bit 2 | 20 | 駒種を決定するハフマン符号の2ビット目 | 香桂銀金角飛 | 186 |
| pt\_bit 3 | 8 | 駒種を決定するハフマン符号の4ビット目 | 金角飛 | 206 |
| pt\_bit 4 | 4 | 駒種を決定するハフマン符号の5ビット目 | 角飛 | 214 |
| color | 38 | 先後どちらの駒かのフラグ | 歩香桂銀金角飛 | 218 |

### 駒種のエンコード

駒種は以下のハフマン符号でエンコードされます。

| Piece Type | pt\_bit 0 | pt\_bit 1 | pt\_bit 2 | pt\_bit 3 | pt\_bit 4 |
|------------|-----------|-----------|-----------|-----------|-----------|
| Pawn       |     0     |     -     |     -     |     -     |     -     |
| Lance      |     1     |     0     |     0     |     -     |     -     |
| Knight     |     1     |     0     |     1     |     -     |     -     |
| Silver     |     1     |     1     |     0     |     -     |     -     |
| Gold       |     1     |     1     |     1     |     0     |     -     |
| Bishop     |     1     |     1     |     1     |     1     |     0     |
| Rook       |     1     |     1     |     1     |     1     |     1     |

### マスのインデックス

マスのインデックスは以下のように0から80まで割り当てられます。
玉の位置はこのインデックスで表現します。

```
| 9| 8| 7| 6| 5| 4| 3| 2| 1|  
+--+--+--+--+--+--+--+--+--+--
|72|63|54|45|36|27|18| 9| 0|一
|73|64|55|46|37|28|19|10| 1|二
|74|65|56|47|38|29|20|11| 2|三
|75|66|57|48|39|30|21|12| 3|四
|76|67|58|49|40|31|22|13| 4|五
|77|68|59|50|41|32|23|14| 5|六
|78|69|60|51|42|33|24|15| 6|七
|79|70|61|52|43|34|25|16| 7|八
|80|71|62|53|44|35|26|17| 8|九
```

### 持ち駒

盤上の玉以外の駒がN枚ある場合、持ち駒は38-N枚存在します(駒落ち等には後述の拡張仕様で対応します)。
colorフィールドは先頭Nビットが盤上の駒の先後フラグに対応し、末尾38-Nビットが持ち駒の先後フラグに対応します。
持ち駒を`歩香桂銀金角飛`の順に並べます。
盤上の駒の数を駒種ごとに数え、各々の最大枚数から引いた数だけ持ち駒があるので、先手の駒の数だけ0、後手の駒の数だけ1を`color`フィールドの末尾(MSB側)に埋めます。
同じ駒種の中で先後の順番はなんでもよく、先後先先後のように並べることも可能ですが、便宜上先手の駒を先に埋めるものとします。
例えば、先手が歩を3枚、銀を2枚、後手が歩を2枚、桂を1枚、銀を1枚持っている場合、colorフィールドの末尾9bitはLSB側から順に`00011 1 001`となります。
promoted, pt\_bit各フィールドも同様に持ち駒分のビットを末尾に埋めますが、駒種が確定しているため、すべて0で埋めます(拡張仕様ではpt\_bitも利用します)。

### エンコード例

初期局面のエンコード例を示します。

SFEN: `lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1`

| フィールド | ビット列(LSB to MSB) |
|-------|-------|
| side\_to\_move | `0` |
| occupied | `101000101 111000111 101000101 101000101 0100010 101000101 101000101 111000111 101000101` |
| kings | `0011010 0010010` |
| is\_promoted | `0000 000000 0000 00 00 00 0000 000000 0000` |
| pt\_bit 0 | `1001 110011 1001 1001 00 1001 1001 110011 1001` |
| pt\_bit 1 | `00 0110 11 11 11 11 0110 00` |
| pt\_bit 2 | `00 1111 00 11 11 00 1111 00` |
| pt\_bit 3 | `11 00 00 11` |
| pt\_bit 4 | `01 10` |
| color | `1100 111000 1100 1100 10 1100 1100 111000 1100` |

エンコード結果:

| Binary | Hex |
|--------|-----|
| `01010001 01111000 11110100 01011010` | `8A 1E 2F 5A` |
| `00101010 00101010 00101101 00010111` | `54 54 B4 E8` |
| `10001111 01000101 00110100 01001000` | `F1 A2 2C 12` |
| `00000000 00000000 00000000 00000000` | `00 00 00 00` |
| `10011100 11100110 01001001 10011100` | `39 67 92 39` |
| `11100100 01101111 11110110 00001111` | `27 F6 6F F0` |
| `00111100 11110011 00001101 10110011` | `3C CF B0 CD` |
| `10001100 11001011 00110011 10001100` | `31 D3 CC 31` |

pt\_bit 0 のビット列がどのように決定されているかを図示します。
pt\_bit 0 は玉以外の駒が存在する各マスに、歩なら0、それ以外の駒なら1を立てます。

```
| 9| 8| 7| 6| 5| 4| 3| 2| 1|  
+--+--+--+--+--+--+--+--+--+--
| 1| 1| 1| 1|--| 1| 1| 1| 1|一
|--| 1|--|--|--|--|--| 1|--|二
| 0| 0| 0| 0| 0| 0| 0| 0| 0|三
|--|--|--|--|--|--|--|--|--|四
|--|--|--|--|--|--|--|--|--|五
|--|--|--|--|--|--|--|--|--|六
| 0| 0| 0| 0| 0| 0| 0| 0| 0|七
|--| 1|--|--|--|--|--| 1|--|八
| 1| 1| 1| 1|--| 1| 1| 1| 1|九
```

これをマスのインデックス順に読んでいくと、LSBから順に`1001 110011 1001 1001 00 1001 1001 110011 1001`となります。

### 拡張仕様: 駒落ち対応

駒落ちや詰将棋等でゲームから一部の駒が除去された局面に対応するため、以下の拡張仕様を定義します。
このリポジトリの実装では、高速化のためにこの拡張仕様には対応していません。

玉が盤上に存在しない場合、kingsには玉の位置の代わりに126/127を設定します。
このとき、kingsの最下位ビットをoccupiedフィールドの80ビット目として扱い、玉が盤上に存在しないことで不足する1ビットを補います。
両方の玉が盤上に存在しない場合、先手玉位置の最下位ビットをoccupiedの80ビット目、後手玉位置の最下位ビットをoccupiedの81ビット目として扱います。

玉以外の駒の総数が38枚未満になる場合、そのままでは持ち駒の枚数を正確に表現できません。
colorフィールドの末尾で持ち駒の所有者を区別したように、pt\_bit 0フィールドの末尾でそれが持ち駒か除去された駒かを区別します。0なら持ち駒、1なら除去された駒を表します。持ち駒と除去された駒の順番は任意ですが、便宜上持ち駒を先に埋めるものとします。
除去された駒のcolorはすべて0で埋めます。
例えば、先手が歩を3枚、銀を2枚、後手が歩を2枚、桂を1枚、銀を1枚持っており、香が1枚、銀が1枚除去されている場合、pt\_bit 0フィールドの末尾10bitはLSB側から順に`00000 1 0 0001`となります。

## 表現のコンパクト化

SSPFv1フォーマットは将棋の局面を256ビットで表現しますが、追加の計算コストを許容できる場合、さらにコンパクトに表現することが可能です。

### side\_to\_moveのoccupiedへの埋め込み

occupiedフィールドは79ビットですが、1が立っているビットの数は最大38個です。
したがって、後手番の場合、occupiedフィールドの各ビットを反転することで、occupiedフィールドの情報を失わずに1ビットの情報を埋め込むことが可能です。
デコード時には、occupiedフィールドの1が立っているビットの数を数え、38個以下であれば先手番で、occupiedはそのまま、39個以上であれば後手番で、occupiedは各ビットを反転して復元します。

### kingsの圧縮

kingsフィールドは14ビットですが、玉の位置は0から80までの81通りしか存在しません。玉が盤上に存在しない場合も含めると(occupiedを補充する1ビットを含めて)83通りです。
したがって、2つの玉の位置の組み合わせは83×83=6889通りしか存在せず、13ビットで表現可能です。

### ハフマン符号の最適化

飛車・角の位置をkingsと同様に個別の座標で表現することで、残りの駒に対するハフマン符号の効率が向上します。
cf. https://yaneuraou.yaneu.com/2016/07/02/compressing-a-shogi-position-into-256-bits/#comment-7236
玉と異なり、飛車・角は持ち駒として存在する可能性があるため、各駒のインデックスを次のようにします(盤上にないケースでは、最下位ビットはoccupiedフィールドの末尾に補充する)。

- 盤上にある場合: 0〜80
- 持ち駒として存在する場合: 81/82
- 存在しない場合: 83/84

85 * 85 = 7225 < 8192 = 2 ^ 13なので、飛車・角それぞれ2駒の位置を13ビットで表現でき、合計26ビットとなります。
さらに、飛車・角それぞれについてインデックスの小さい順に持つことにしておけば、85 * (85 + 1) / 2 = 3655 < 4096 = 2 ^ 12となり、飛車・角2駒を12ビットで表現でき、合計24ビットとなります。
これらの工夫によりさらに4ビット削減が可能です。

### 余剰ビットの利用

上記の圧縮を行うと、合計6ビットの余剰が生じます。
同一局面の出現回数(0-3)や評価値の符号(先手有利/後手有利)など、他の情報を埋め込むことが可能です。
